<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>[working code]</title>
 <link href="http://working-code.com/atom.xml" rel="self"/>
 <link href="http://working-code.com/"/>
 <updated>2010-05-18 14:09:36 -0700</updated>
 <id>http://working-code.com</id>
 <author>
   <name>Kevin Stewart</name>
   <email>kevin@working-code.com</email>
 </author>
 
 
 <entry>
   <title>Mostly Cloudy</title>
   <link href="http://working-code.com/2010/04/30/mostly-cloudy.html"/>
   <updated>2010-04-30 00:00:00 -0700</updated>
   <id>http://working-code.com/2010/04/30/mostly-cloudy</id>
   <content type="html"><p>In a <a href='/2010/02/20/mobile-is-the-new-desktop.html'>previous post</a>, I talked about my preference for developing for the Web as opposed to jumping on the native application bandwagon that is dominating mobile development these days. In this post, I&#8217;d like to go deeper on that topic.</p>

<p>At my <a href='http://adobe.com'>day job</a>, I spend a good part of my day explaining services to people. Some may say that we don&#8217;t <a href='http://www.mslater.com/2009/12/4/10-years-later-thoughts-on-phototablet-fotiva-adobe'>get the Web</a> and there is probably some truth to that given <a href='http://www.apple.com/hotnews/thoughts-on-flash/'>recent events</a>. Yet, being inside the <strike>sausage</strike> software factory has shown me that it is more a cultural issue; we rose to prominence during the Age of Software as a Product. Combine that with a specialist and generally long-tenured workforce, it is no surprise that we have difficulty adapting to the software as a service era.</p>

<p>One major mind shift for people coming from a desktop application development perspective is the idea that <em>multi-user</em> is the rule, not the exception. Also, the fact that since you no longer have the hassle of creating installers that have to deal with wildly varying system configurations, you have more flexibility in the choice of languages, libraries and applications you can use to build your service. You, the software developer, have a lot more freedom.</p>

<p>Of course, there are tradeoffs. As opposed to worrying about the intricacies of your widget toolkit, keeping your interface responsive and, of course, making it attractive and functional you have to deal with lower-level details. Concurrency. Latency. Throughput. Serialization. <em>This stuff is really cool, BTW.</em></p>

<p>I tend to call this <strong>the iceberg</strong>. Most people see the part that penetrates the water&#8217;s surface, but never pay attention to the incredible mass that lurks below. Another analogy, soon to be relegated to the historical trash can, is the <strong>dial tone</strong>. Do you ever stop to consider all the engineering that goes behind producing that pleasing tone that informs you that you can press a few buttons and connect with another human being? Of course you don&#8217;t! <em>You tweet, just like me. What the hell is a dial tone?</em></p>

<p>A <a href='http://blog.kevingoldsmith.com/'>co-worker</a> and I were talking one day and he mentioned a former colleague of his who was a Unix geek before going to Microsoft for many years. When this guy left and went back to hacking Unix, he was (pleasantly) surprised how easy it was for him to jump back into things. Very little had changed in all that time. vi and emacs were still the dominant editors. More importantly, the programming model hadn&#8217;t changed. Write small programs that do one thing well and connect them via pipes.</p>

<p>My friend and I pondered this. How, after all this time and with the rapid pace of technology, was Unix not only mostly the same but <strong>thriving</strong>? My theory: cause its model works.</p>

<p>Take concurrency. Hard-assed problem, no one will argue that. And, we have all learned the hard way that <em>threads suck</em>. And while there are great new constructs like <em>actors</em> and <em>software transactional memory</em>, they are generally implemented in obscure and academic languages like Scala and Haskell (<em>here comes the hate mail!</em>)</p>

<p>Or, you could fall back to the Unix process model. <strong>fork</strong> and <strong>exec</strong> still work well for a lot of cases. Building an asynchronous backend for a service requires long-running processes for message queues and daemon processes for pulling jobs and spinning up workers. This is Mom and apple pie for Unix wonks.</p>

<p>Add to that the complexity of processing large amounts of data or responding in near realtime to requests from multiple clients. As great as the frameworks are that come out of Cupertino, they&#8217;re not going to wrap up that kind of stuff and make it easy for the Cocoa Touch crowd to deploy highly scalable services. If it happens at all, it will come out of <a href='http://aws.amazon.com'>Seattle</a>.</p>

<p>You can&#8217;t abstract everything. At some point, you have to know how things <em>work</em>. Even with amazing cloud platforms like <a href='http://aws.amazon.com/ec2/'>Amazon EC2</a>, <a href='http://heroku.com'>Heroku</a> (<em>LOVE</em> what these guys are doing!) and <a href='http://engineyard.com'>Engine Yard</a> you need to understand how things interact, how latency will impact you and how to orchestrate multiple cooperating services. You have to internalize that <em>failure happens, and you need to figure out how to deal with it because you can&#8217;t prevent it</em>.</p>

<p>So, how does this relate to the new world of mobile development? Aside from games and a handful of other apps, how many apps do you use that are <strong>NOT</strong> connected to some kind of service? All those location-aware, map intensive, real-time and messaging apps that you couldn&#8217;t live without are just the <a href='http://en.wikipedia.org/wiki/Icebergs'>tips of the icebergs</a>. The services that push data to these apps are amazingly intricate and complex. And like the ice below the surface, most people (including app developers) shy away from understanding how they are designed and implemented. They do realize, however, that they are necessary.</p>

<p>HTTP will be with us for a while, and TCP/IP even longer. The Web may recede behind pay walls, but you&#8217;ll still use the Internet. Android may overtake iPhone OS or maybe Microsoft will come from behind again and convince people that Windows Phone 364 is for the <em>social network ready</em> enterprise. Whatever. No matter the platform, the genie is out of the bottle. People expect to be online and connected to services no matter the device. Amazingly, services today can work with any kind of client that has a network library and a way to parse the data you receive (assuming you designed it correctly).</p>

<p>There are a slew of hard problems to solve on the services side of the new software development landscape. Sure, the front end is what people see and respond to for the most part. But, in reality, people are attracted to the <strong>value</strong> that a well-designed app and its corresponding service provide. While I can appreciate great visual and interaction design, I am not especially skilled at either. My creativity comes out in figuring out how to leverage things like <a href='http://nodejs.org/'>node.js</a>, <a href='http://code.google.com/p/redis/'>Redis</a>, <a href='http://unicorn.bogomips.org/'>Unicorn</a> and <a href='http://kr.github.com/beanstalkd/'>beanstalkd</a>.</p>

<p>If you made it this far, I recommend you read The State of the Internet Operating System, <a href='http://radar.oreilly.com/2010/03/state-of-internet-operating-system.html'>Part I</a> and <a href='http://radar.oreilly.com/2010/04/handicapping-internet-platform-wars.html'>Part II</a>. They don&#8217;t call Tim O&#8217;Reilly <em>The Prophet</em> for nuthin&#8217;!</p></content>
 </entry>
 
 <entry>
   <title>3 Is The Magic Number</title>
   <link href="http://working-code.com/2010/03/14/3-Is-The-Magic-Number.html"/>
   <updated>2010-03-14 00:00:00 -0800</updated>
   <id>http://working-code.com/2010/03/14/3-Is-The-Magic-Number</id>
   <content type="html"><p>More or less. At least, when it comes to software development these days. That&#8217;s not to say it&#8217;s a hard and fast number, but it is the sweet spot in my experience. But, before people start raking me over the coals asking, <em>&#8220;Do you actually believe only 3 people could write something as complex as Photoshop?&#8221;</em> let me set the context here and now <em>(Oh, and to answer the previous question, Yes)</em> :</p>

<ul>
<li>A large percentage of software development is in building Web applications and lately smaller, mobile applications for iPhones, Android devices and Blackberrys.</li>

<li>There is a vibrant community of independent software developers that are building desktop applications with teams as small as <strong>1</strong> and making a good living.</li>

<li>The majority of large applications did not START as large applications. They were small applications that <em>GREW</em> into large applications. And when they started, there were only a few developers (<em>even Photoshop!</em>).</li>
</ul>

<h4 id='rethinking_brookss_law'>Rethinking Brooks&#8217;s Law</h4>

<p>As often misquoted as <a href='http://en.wikipedia.org/wiki/Brooks%27s_law'>Brooks&#8217;s Law</a> is, the core tenet is still valid. The communication costs incurred by adding more people to a project can be crippling.</p>

<blockquote>
<p>&#8220;You won&#8217;t catch me advocating for &#8216;hard-working average programmers&#8217;. What I do believe is: you should stock your team with only rockstars, between 2 and 4 of them. I&#8217;ve worked on teams that only had 3 people. I&#8217;ve worked on teams with about 16. I was a consultant, I&#8217;ve worked on a lot of teams - big and small. My experience was that the smaller teams were much more effective, every time.&#8221;</p>
</blockquote>

<p><strong><em>Jay Fields, <a href='http://blog.jayfields.com/2010/03/pairing-isnt-solution.html'>Pairing isn&#8217;t the Solution</a> via <a href='http://twitter.com/zedshaw/status/10356819700'>Zed Shaw</a></em></strong></p>

<p>The right way to think about Brooks&#8217;s Law is to pay more attention to how we form teams in the first place. Too many companies think of developers as interchangeable cogs and just throw people onto projects as if what they are working on and who they work with do not matter. <strong>NOTHING</strong> could be farther from the truth.</p>

<h4 id='software_development_is_a_social_activity'>Software Development is a Social Activity</h4>

<p>Whether you are pair programming on some Java code, chatting in the #mongodb IRC channel on <a href='http://freenode.net'>freenode</a> or typing:</p>

<pre><code>git push github master</code></pre>

<p>writing code is a social activity. Developers need to talk to other developers, bounce ideas off each other or just show off. It&#8217;s a <em>craft</em>. That&#8217;s why the whole idea of software craftsmanship holds so much appeal. We applied Industrial Revolution principles to knowledge work and that&#8217;s just insane. Unfortunately, many large companies still haven&#8217;t <a href='http://www.entertonement.com/clips/pmrmbndcrh--Did-you-see-the-memo-about-thisOffice-Space-Gary-Cole-Bill-Lumbergh-'>gotten the memo</a>.</p>

<p>Large companies have introduced so much overhead to the process of delivering software it&#8217;s amazing any gets released at all. Much of this overhead is related to <em>managing communication between functional teams</em>. Interesting&#8230;</p>

<p>Has any one considered WHY we even have functional teams? Why isn&#8217;t everyone involved on the project on one team? <em>Duh! Too many people.</em> Why do we have so many people? <em>Because we need specialists, so we break them up into teams, give them managers and then add project managers to facilitate communication&#8230;</em> Which, of course, is absolutely necessary because we all know that engineers don&#8217;t have <a href='http://www.break.com/usercontent/2008/4/Office-Space-I-have-people-skills-488721.html'>people skills</a>.</p>

<p>Except that is a big, fat, honking <strong>LIE</strong>. The real issue is that developers have to hold a ton of information in their heads and attain a high state of concentration. They understandably get a wee bit irritated every time they have to context switch to address the latest issue of <strong>The Institution</strong>. Large teams introduce every possible detriment to a developer:</p>

<ol>
<li>Interruptions</li>

<li>Unnecessary communication</li>

<li>Low bandwidth communication</li>
</ol>

<p>How can we turn this around? In my utopian vision of the future, software development teams are comprised of:</p>

<ol>
<li>Developers</li>

<li>Designer</li>
</ol>

<p>When I say <em>developers</em>, I am stating that these people fulfill the roles of developers, testers and operations people. If you had a development manager on the team before I hope s/he can code. Otherwise, we have no need for them.</p>

<p>I also think there should be a <strong>SINGLE</strong> designer on the team that is both the interaction and visual designer. This, in my mind, helps retain the conceptual integrity of the user experience design. I completely agree with <a href='http://elliotjaystocks.com/blog/web-designers-who-cant-code/'>Elliot Jay Stocks</a> that designers must be able to code in this day and age. More importantly, they should heed at least one part of Ryan Singer&#8217;s description of the <a href='http://37signals.com/svn/posts/2135-podcast-episode-7-ryan-singer-on-the-37signals-design-process'>37signals design process</a>&#8230;work in the code. By writing HTML and CSS, checking templates into version control and running the software locally on their own machines during development designers will have a much more intimate relationship with the final product. In the process, it helps address that whole <a href='http://www.adobe.com/resources/business/rich_internet_apps/workflow/'>designer/developer workflow</a> thing.</p>

<h4 id='but_that_doesnt_scale'>But, That Doesn&#8217;t Scale&#153;</h4>

<p>Of course it does, just not in the way you&#8217;ve been conditioned to think. Jason Fried gets it:</p>

<blockquote>
<p>&#8220;We&#8217;re going to start working in teams. A team is made of three people: One designer and two programmers. A system administrator will also assist the team when necessary. To start, we will have two dedicated teams plus one slack team. The slack team is available to help either team, or take on other stuff that inevitably comes up. In March we expect to have a third team dedicated to the products.&#8221;</p>
</blockquote>

<p><strong><em>Jason Fried, <a href='http://37signals.com/svn/posts/2099-2010-the-year-of-the-products-a-new-way-of-working'>2010: The year of the products + a new way of working</a></em></strong></p>

<p>Microsoft has/had a similar concept called feature teams. Amazon does the two-pizza team thing. It&#8217;s intrinsic to human nature to prefer small circles. Ever notice at a large party that everyone breaks off into small groups of 4-6 people to have a conversation? Why do you think that is? Seth Godin gives us a hint:</p>

<blockquote>
<p>&#8220;Handshakes. How many handshakes do you need to introduce three people? Only three. Ishita, meet Susan. Susan, meet Clay. Clay, meet Ishita. Four people need twice as many, six. And five people? Ten.&#8221;</p>
</blockquote>

<p><strong><em>Seth Godin, <a href='http://www.amazon.com/Linchpin-Are-Indispensable-Seth-Godin/dp/1591843162/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1268610473&amp;sr=1-1'>Linchpin</a></em></strong></p>

<p><em>Who will talk to the customers, get their requirements, understand the market&#8230;.?</em></p>

<p>You haven&#8217;t been following along, have you?</p></content>
 </entry>
 
 <entry>
   <title>Mobile Is The New Desktop</title>
   <link href="http://working-code.com/2010/02/20/mobile-is-the-new-desktop.html"/>
   <updated>2010-02-20 00:00:00 -0800</updated>
   <id>http://working-code.com/2010/02/20/mobile-is-the-new-desktop</id>
   <content type="html"><p>Given all the hubbub around the iPad and everyone wishing for the fall of my <a href='http://adobe.com'>employer&#8217;s</a> platform, I&#8217;ve been wondering how best to express my thoughts on the current state of affairs.</p>

<p>Several years ago, I made the personal decision to focus on Web development. Primarily, building backend applications and Web services for browser-based clients. While I love working for Adobe, I am not really interested in Flash or AIR technically. That is probably due in part to the years I&#8217;d spent doing cross-platform development for Windows and Mac OS. Flash, in my opinion, is good in small doses. And AIR is mostly useful (to me at least) when used where people would have built a Visual Basic application 15 years ago. Even that is a weak argument as those people would build a Web application today.</p>

<p>At the end of the day, I grew tired of trying to keep up with Microsoft&#8217;s technology du jour. I think Joel Spolsky&#8217;s essay <a href='http://www.joelonsoftware.com/articles/APIWar.html'>How Microsoft Lost the API War</a> sums up my feelings pretty nicely:</p>

<blockquote>
<p>Outside developers, who were never particularly happy with the complexity of Windows development, have defected from the Microsoft platform <em>en-masse</em> and are now developing for the web&#8230;None of this bodes well for Microsoft and the profits it enjoyed thanks to its API power. The new API is HTML, and the new winners in the application development marketplace will be the people who can make HTML sing.</p>
</blockquote>

<p>And although at that time I came to favor the Mac as my platform of choice, I couldn&#8217;t bring myself to develop for it. I just had no desire to become a <a href='http://www.tbray.org/ongoing/When/200x/2003/07/12/WebsThePlace'>sharecropper</a>. Using a Mac as my personal computing platform, but developing for the Web using Unix/Linux as my server OS felt <strong><em>right</em></strong>.</p>

<p>Last year, I attended Apple&#8217;s Worldwide Developer Conference. Although the bulk of the conference was about iPhone OS 3.0 and the bazillions of apps being developed, I mostly went to the Web/Safari tracks. All the work regarding HTML5 support seemed much more relevant. Web development was moving forward again.</p>

<p><strong>STILL</strong>, everybody wanted to know how to build native iPhone apps so they could sell them in the App Store and become millionaires. Aside from games and a few other visually complex applications, I didn&#8217;t get it. Sure, the App Store solved some problems and was a great way to <strong><em>maybe</em></strong> get your app in front of millions of people. But, at what cost?</p>

<p>Flash forward to today. There has been plenty of griping about the App Store review process. The sheer number of apps makes it difficult to find the gems in a sea of crap. Reviews are outdated and can potentially affect sales even though the stated issues may have already been addressed. Frankly, the majority of apps I see in the App Store could <strong>EASILY</strong> have been webapps, including <a href='http://ego-app.com'>some that friends of mine have made</a>.</p>

<p>Android and Blackberry are no better. I have no desire to develop in Java again and if I did I would use it on the server like I used to. Palm actually appears to have gotten it right with webOS but, umm&#8230;, nobody&#8217;s really buying those devices.</p>

<p>I tried, unsuccessfully, to write an iPhone app. I&#8217;ll admit I bit off more than I could chew at first and my own disgust for IDEs and C/C++/Objective C got in the way. Considering Objective C and Cocoa Touch (or C# and MonoTouch) are the only real ways to build a native app for the iPhone I probably won&#8217;t be building native apps anytime soon, unless <a href='http://macruby.org'>MacRuby</a> adds iPhone support. No, I won&#8217;t use the <a href='http://labs.adobe.com/technologies/flashcs5/appsfor_iphone/'>Flash iPhone Packager</a>; see my position statement above.</p>

<p>The iPhone (and now, the Droid and Nexus One and <em>insert next model smartphone here</em>) and iPad are showing what the future holds. Mobile devices are the new personal computers. Their form factor combined with native apps, including desktop class Web browsers, make them the perfect devices for information consumption. Desktops and laptops will be relegated to mostly <em>content creation</em> tasks. I can easily see my son&#8217;s first computer being a tablet of some sort. And, that&#8217;s great.</p>

<p>As a developer, however, I STILL don&#8217;t want to get sucked into the &#8220;develop for our platform&#8221; crap that dominated the desktop era. I will readily concede that there is still a need for native applications. Heck, I still use them! I&#8217;m just not interested in <em>writing them</em>.</p>

<p>Many talk about <strong>software plus services</strong> but this is usually just a way to position rich client technology. I believe in software that <em>complements</em> services. iTunes is actually a good example of this, but the plethora of Twitter clients is an even better one. Twitter the Web service was valuable in and of itself, but by exposing a great API, clients could be built that made it even more valuable. I&#8217;m kinda partial to <a href='http://www.atebits.com/tweetie-iphone/'>Tweetie</a> myself.</p>

<p>But, Tweetie 2 is not on Android and it may never be. I&#8217;m sure I could find a reasonable substitute as I am considering buying a Nexus One. But, as a developer myself, do I want to invest time in learning iPhone development AND Android development AND Blackberry development (and maybe even Palm development). &#8216;Cause it&#8217;s just not the learning curve involved, but dealing with all these damn App Stores that are cropping up. You know every time Apple does something competitors copy it&#8230;badly. My head is hurting already!</p>

<p>No, I&#8217;ll spend my time improving my Ruby and Javascript skills. Maybe I&#8217;ll pick up Erlang and Clojure to stretch my brain a bit. I&#8217;ll DEFINITELY learn HTML5 and CSS3. But, I&#8217;ll let others tackle developing native apps for all these mobile devices; I&#8217;m sure I&#8217;ll even buy a few.</p>

<p>I&#8217;m sticking with The Web.</p></content>
 </entry>
 
 <entry>
   <title>API Design is Interaction Design</title>
   <link href="http://working-code.com/2009/06/10/api-design-is-interaction-design.html"/>
   <updated>2009-06-10 00:00:00 -0700</updated>
   <id>http://working-code.com/2009/06/10/api-design-is-interaction-design</id>
   <content type="html"><p>For the past few weeks, I have been working with my team on refining the <span class="caps">REST</span> <span class="caps">API</span> for our Web service. While there will be some new additions in order to meet requirements for applications that will build upon the <span class="caps">API</span>, many of the changes are refinements. Early adopters and our own experience has provided a treasure trove of information that has guided the development of the latest version.</p>
<p>From the very beginning, I chose a <span class="caps">REST</span> Oriented Architecture (<span class="caps">ROA</span>) for the service. To me, this just seemed obvious. I&#8217;ve followed the development of <span class="caps">XML</span>-<span class="caps">RPC</span> and <span class="caps">SOAP</span> for years. For awhile, <span class="caps">XML</span>-<span class="caps">RPC</span> seemed pretty cool and simple to me especially when compared to the mess that is <span class="caps">SOAP</span> (which evolved into <strong><em>WS-Death Star</em></strong>). However, in practice I always ended up sending some simple, Plain Ol&#8217; <span class="caps">XML</span> over <span class="caps">HTTP</span>. For the majority of cases, <span class="caps">HTTP</span> and URIs covered the functionality I needed sufficiently.</p>
<p>As <span class="caps">REST</span> became a more prevalent meme, I got a copy of <a href="http://www.amazon.com/RESTful-Web-Services-Leonard-Richardson/dp/0596529260/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1244646726&amp;sr=8-1">RESTful Web Services</a> and read it cover-to-cover. I recommend this book to <strong><span class="caps">ANYONE</span></strong> building Web applications. It put what was common practice for me into context and really illustrated what <span class="caps">REST</span> and <span class="caps">ROA</span> are really about and what tradeoffs need to be made in every application.</p>
<p>One part of the book that really stood out for me were the sections on <strong>resource design</strong>. Instead of the highly procedural <span class="caps">XML</span>-<span class="caps">RPC</span> or my own custom-coded <span class="caps">XML</span> schemas in my <span class="caps">POX</span>/<span class="caps">HTTP</span> implementations, <span class="caps">REST</span> made me think more about the actual objects, or resources, that I wanted to interact with over the network. Doing this forced me to think harder about naming and behaviors (whether or not they mapped cleanly to <span class="caps">GET</span>, <span class="caps">PUT</span>, <span class="caps">HEAD</span>, <span class="caps">DELETE</span> and, of course, <span class="caps">POST</span>). For error conditions, there was almost always an <span class="caps">HTTP</span> status code that would work for us. And, <span class="caps">HTTP</span> headers were incredibly useful in dealing with metadata.</p>
<p>So, on my first pass with our <span class="caps">API</span> I attempted to adhere to RESTful principles. After identifying my resources, I spent even more time thinking about <strong>representations</strong>, the content types and schemas for the data my service would consume and produce. Many of my early assumptions changed quickly as I worked through this process (and again as we started working on the latest version) For instance, I once considered <span class="caps">XML</span> a safe, de facto format to support in an <span class="caps">API</span>. Then, along came <span class="caps">JSON</span>. When, I looked at some of my earlier representations I saw almost an order or magnitude difference in the size of an <span class="caps">XML</span> response compared to its <span class="caps">JSON</span> counterpart <em>for exactly the same data!</em> Now, in many cases, <span class="caps">XML</span> is a requirement. However, if you have the ability to define exactly which representations you will support, think long and hard about when to use <span class="caps">XML</span>. Given the proliferation of libraries in almost every conceivable language, <span class="caps">JSON</span> is almost as de facto a choice as <span class="caps">XML</span> and has even more practical benefits although there are also downsides, like potential security vulnerabilities. As in everything else, one should pick the tools that help solve the problem at hand.</p>
<p>The first versions of our <span class="caps">API</span> worked fine. The true test was seeing the number of people who just went to our documentation page and started coding against it. Generally, we received fewer than half a dozen questions via email before they were able to productively use the service. That&#8217;s a huge win! We also ate our own dog food by prototyping clients for the service using:</p>
<ul>
	<li>curl</li>
	<li>Ruby (using <a href="http://merbivore.com">Merb</a> as our framework)</li>
	<li>Flash (ActionScript 3 and the Flex framework)</li>
	<li>Adobe <span class="caps">AIR</span></li>
</ul>
<p>All the clients worked well, with the minor exception of Flash. Unfortunately, Flash has some limitations with respect to things like:</p>
<ul>
	<li><span class="caps">HTTP</span> response codes other than 200</li>
	<li><span class="caps">PUT</span> and <span class="caps">DELETE</span></li>
	<li>Custom <span class="caps">HTTP</span> headers</li>
	<li>Using the User-Agent to identify the Flash Player</li>
</ul>
<p>Surprisingly, Adobe <span class="caps">AIR</span> works just fine with our <span class="caps">REST</span> <span class="caps">API</span>. Here, we had a nicely defined <span class="caps">API</span> but needed to make it work with Flash. The thought of either creating a separate <span class="caps">API</span> or moving to a least common delimiter approach for everyone was not appealing. However, there was actually a simple solution. If we added a prefix to all our <span class="caps">API</span> endpoints, we would know that the client was the Flash Player. In our Web service code, we wrote a proxy that would extract input from the request and then call the <span class="caps">REST</span> <span class="caps">API</span> directly. When the <span class="caps">API</span> code generated a response, the proxy would repackage it appropriately for the player:</p>
<ul>
	<li>Always generate a 200 response</li>
	<li>In the response body, use an <span class="caps">XML</span> document to house:
	<ul>
		<li>The actual <span class="caps">HTTP</span> response code</li>
		<li>Standard and custom headers</li>
		<li>Response body from the <span class="caps">REST</span> <span class="caps">API</span></li>
	</ul></li>
</ul>
<p>The beauty of this approach is that it is fairly generic. As we add new endpoints, the proxy does not need to be changed. The Web frameworks router just tries to match everything after the prefix against our existing RESTful routes. If we have a match, then the proxy calls that <span class="caps">API</span>. Otherwise, we return an error. Simple. So, how is this interaction design? Well, developers are users, right? For the most part, we try every new <span class="caps">API</span> by using <strong>curl</strong> or these days, <a href="http://rest-client.heroku.com/rdoc/">rest-client</a>. If the <span class="caps">API</span> seems too cumbersome using either of these tools, then we&#8217;ve probably done something really wrong. And, we did. There were a few APIs that were a little unwieldy or confusing due to the naming, so we focused on them a lot for the latest version. Deprecation can be a good thing.</p>
<p>As developers, we use tons of APIs from various sources. Some are good, some not so good. <a href="http://al3x.net">Alex Payne</a>, the <span class="caps">API</span> Lead at <a href="http://twitter.com">Twitter</a> gave a great presentation the <a href="http://www.slideshare.net/al3x/the-interaction-design-of-apis">interaction design of APIs</a>. I almost didn&#8217;t write this blog post because Alex&#8217;s presentation was so spot on. But, I think it is a topic that may not get the attention it deserves so I&#8217;ll throw my hat in the ring. In our <span class="caps">API</span>, we leverage an internal user authentication service as opposed to rolling our own. This service had an &#8220;<span class="caps">XML</span> <span class="caps">API</span>&#8221; that was essentially a Plain Ol&#8217; <span class="caps">XML</span> over <span class="caps">HTTP</span> endpoint that called into their Java code. Not really RESTful, but generally workable. The problem was that their <span class="caps">XML</span> <span class="caps">API</span> did not have feature parity with their Java and ActionScript APIs. We were told that this would be addressed with the next version of the <span class="caps">API</span> and there would be a new &#8220;<span class="caps">REST</span> <span class="caps">API</span>&#8221;. Great!</p>
<p>Well, maybe not so great. The user authentication service was growing to meet the needs of multiple clients and, like us, did not want to rewrite their code to address their non-primary clients. Their approach was to use a proxy approach as well that generated interfaces from their Java class and method definitions. See where this is going yet?</p>
<p>The <span class="caps">XML</span> generated from the class and method definitions was approximately <strong>an order of magnitude</strong> larger than the previous <span class="caps">XML</span>. Sure, we got feature parity but good luck trying to figure out how to <span class="caps">USE</span> the <span class="caps">API</span>. I had to have at least 5 browser tabs open and look through JavaDocs to figure out how to create an account! I know, I know&#8230; once we get it done it&#8217;s done&#8230;or is it? What happens when they change method names or parameter lists? Alex defines &#8220;The <strong>Humane</strong> <span class="caps">API</span>&#8221; as:</p>
<ul>
	<li>Explorable</li>
	<li>Predictable</li>
	<li>Consistent</li>
</ul>
<p>This user authentication <span class="caps">API</span> is not humane currently. I suspect that this is rooted in its implementation. It is a Java-based Web service and there are tons of tools and APIs that can turn Java objects into Web services. Unfortunately, the services generated are best consumed by <em>other Java applications and services</em>. My team uses <a href="http://danube.com/scrumworks/pro">ScrumWorks Pro</a> for our agile planning and task tracking. It too has one of these Java-generated Web service APIs which I just find inscrutable. I&#8217;ve seen similar things in the .<span class="caps">NET</span> world as well. On the Web, Web service clients can be as simple as curl or as complex as a desktop Windows or Mac application like iTunes. Every programming language/tool has its own idioms, but they all have one thing in common: they likely have one or more libraries for communicating via <span class="caps">HTTP</span>.</p>
<p>And that is the interaction design advice I&#8217;d like to impart. Recently, there have been a proliferation of projects that help you build applications and services with nothing more than <span class="caps">HTTP</span>, Javascript/<span class="caps">JSON</span> and general RESTful principles. <a href="http://getcloudkit.com">CloudKit</a> bills itself as an <strong><em>Open Web <span class="caps">JSON</span> Appliance</em></strong>. Once you&#8217;ve downloaded and installed the Ruby gem, you can expose a resource and immediately interact with it using curl. Awesome! And then there is CouchDB, which is getting a ton of attention and for good reason. Jacob Kaplan-Moss, one of the creators of Django, said this of CouchDB in a blog post called <a href="http://jacobian.org/writing/of-the-web/">Of the Web</a>:</p>
<blockquote>
<p>Let me tell you something: Django may be built for the Web, but CouchDB is built of the Web. I&#8217;ve never seen software that so completely embraces the philosophies behind <span class="caps">HTTP</span>. CouchDB makes Django look old-school in the same way that Django makes <span class="caps">ASP</span> look outdated. Let me try to explain what I&#8217;m talking about. You want an <span class="caps">API</span> without having to write a line of code? It&#8217;s called curl, and it ships with your MacBook. And just look at how simple the APIs are in your favorite language.</p>
</blockquote>
<p>If you are building a Web application or service, strive to make it <strong>Of the Web</strong>.</p></content>
 </entry>
 
 <entry>
   <title>Web Development vs. Software Development</title>
   <link href="http://working-code.com/2009/04/13/webdev-vs-swdev.html"/>
   <updated>2009-04-13 00:00:00 -0700</updated>
   <id>http://working-code.com/2009/04/13/webdev-vs-swdev</id>
   <content type="html"><p>From Eric S. Raymond, <em>The Art of Unix Programming, Chapter 11: The Web Browser as a Universal Front End</em></p>
<blockquote>
<p>For a large class of applications, it makes increasing sense not to write a custom <span class="caps">GUI</span> front end at all, but rather to press Web browsers into service in that role. This approach has many advantages. The most obvious is that you don&#8217;t have to write procedural <span class="caps">GUI</span> code &#8211; instead, you can describe the <span class="caps">GUI</span> you want in languages (<span class="caps">HTML</span> and JavaScript) that are specialized for it. This avoids a lot of expensive and complex single-purpose coding and often more than halves the total project effort. Another is that it makes your application instantly Internet-ready; the front end may be on the same host as the back end, or may be a thousand miles away. Yet another is that all the minor presentation details of the application (such as fonts and color) are no longer your back end&#8217;s problem, and indeed can be customized by users to their own tastes through mechanisms like browser preferences and cascading style sheets. Finally, the uniform elements of the Web interface substantially ease the user&#8217;s learning task.</p>
</blockquote>
<p>For most of my career, there has been endless, tedious debate over the nature of software development. Is it math, science, engineering or craft? Well, having gone to an <a href="http://poly.edu">engineering school</a> to study computer science and in the process take a <span class="caps">TON</span> of math, science and engineering courses I can tell you that the majority of what people call software development is a <a href="http://en.wikipedia.org/wiki/Craft">craft</a> and we should stop obsessing over that fact.</p>
<p>I have been a self-professed <strong>computer science bigot</strong> for a long time. I tended to make a distinction between people who had degrees in computer science (or at least studied the foundation stuff) and self taught developers. You know, a caste system. The high priesthood vs. the unwashed masses. And, in the dotcom days, that bias was reinforced when I saw the &#8220;designs&#8221; created by the Perl and <span class="caps">PHP</span> hackers. I have never, and probably will never, write a line of Perl in my life. Of course, some think that Ruby is the new Perl so I may have just lied! :-)</p>
<p>However, after a few years writing Active Server Pages applications with VBScript and then moving back to a more comfortable language in Java with servlets, JavaServer Pages and <span class="caps">JDBC</span> my perspective slowly changed. Sure, I wrote model-view-controller (<span class="caps">MVC</span>) code in classic <span class="caps">ASP</span> just as I did in Java. But, I learned many things by working closely with Web designers. I gained greater appreciation for aesthetics, user experience and <a href="http://www.cooper.com/insights/books/#inmates">interaction design</a> as I built more Web applications. While my stomach churned over some of the hackish code I saw, I realized their true beauty&#8230; they worked and provided value for their users.</p>
<p>Most computer science programs unwittingly reinforce this foolish caste system mentality from the 60s and 70s because faculty see themselves as divorced from the trivialities of <em>pragmatism, usefulness and real-world scenarios</em> because they are teaching theory and not practice. Some institutes of higher learning have at least acknowledged the need for a separate track in <strong>software engineering</strong> that focuses more on what practicing developers need to know: version control, debugging, cross-functional collaboration, etc. However, the very term <em>software engineering</em> still conveys the wrong sentiment that what we do is equivalent to electrical, aerospace or chemical engineering. It, emphatically, is not.</p>
<p>Going off on a tangent for a moment, I used to feel the same way about <strong>game developers</strong>. I used to read Game Developer magazine, especially their Postmortem column, for years and marveled at how little these people seemed to know about basic development principles like object-oriented design. Yet, like Web developers they made products that people paid good money for and enjoyed using. Who cares then if few of them knew how to write a class that properly demonstrated <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">encapsulation, inheritance and polymorphism</a>?</p>
<p>Perhaps, the differences could better be described as <em>web <strong>design</strong> vs. web <strong>development</strong></em>? Unfortunately, this too is a false dichotomy. Web design without development often leads to brochureware. Or, some Web designers fool themselves into thinking that what they are doing is not creating code. I&#8217;ve seen some self-professed designers churn out some awesome Javascript and <span class="caps">PHP</span> or Python yet they don&#8217;t believe that they are developing software (even as they check their code into their Subversion repository&#8230;)</p>
<p>I may be in the minority here, but I actually believe that Apple did the <span class="caps">WRONG</span> thing with the iPhone <span class="caps">SDK</span>. I think they should have stuck to their guns and <span class="caps">NOT</span> come out with a way to build native applications for the iPhone. (Brief pause as multiple people pick their jaws up from the floor.) That&#8217;s right, I said it. I would have been much more impressed if they stuck to the idea that Web applications <span class="caps">ARE</span> applications and can be used across multiple device contexts. Apple could have exposed more of the iPhone&#8217;s features as Javascript objects that developers could utilize in their &#8220;Web&#8221; applications. By caving to the pressure to provide a &#8220;real&#8221; <span class="caps">SDK</span> Apple has continued to perpetuate the caste system. Granted, the iPhone is such a compelling device that many &#8220;Web developers&#8221; grumbled but grudgingly started to learn Objective C and Cocoa in order to build applications for it&#8230;</p>
<p>Wait. <strong>Web developers</strong> learned a language like Objective C that you compile down to a binary in order to deploy on a device? Isn&#8217;t that the domain of <em>software developers</em>?!? The false dichotomy breaks down! There is no <em>us vs. them</em> or <em>hacking vs. engineering</em>. There are only the people who like to tirelessly debate false dichotomies:</p>
<ul>
	<li>vim vs. Emacs</li>
	<li>Tabs vs. spaces</li>
	<li>Python vs. Ruby</li>
	<li>Microsoft vs. everyone else</li>
</ul>
<p>and those of us who care about our craft enough to focus on building beautiful things that people love to use.</p></content>
 </entry>
 
 <entry>
   <title>Seven Things</title>
   <link href="http://working-code.com/2009/01/25/seven-things.html"/>
   <updated>2009-01-25 00:00:00 -0800</updated>
   <id>http://working-code.com/2009/01/25/seven-things</id>
   <content type="html"><p>Damn you, <a href="http://flinglog.com">Brian!</a> for tagging me with this meme. But, since it is currently snowing (again?!?!) here in the Seattle area, I figured I needed a diversion. So here goes&#8230;</p>
<h2>One</h2>
<p>I was born left-handed. My parents are from the West Indies and apparently, being left-handed was considered <span class="caps">BAD</span>. So, at a very young age whenever my Mom saw me doing something with my left hand, she would say &#8220;Use your right hand!&#8221;. My wife told me she thought I was left-handed when she met me because I tended to do things with that hand. Ironically, both my son and our new President are left-handed. I&#8217;ve also learned that lefties tend to be more creative and possibly smarter. See what you&#8217;ve done to me, Mom?</p>
<h2>Two</h2>
<p>I met my wife on a blind date. I was at a party where I met up with some mutual friends. After hours of drinking and talking, one of the girls remarked, &#8220;I can&#8217;t believe you don&#8217;t have a girlfriend. You have to meet our friend, Donna.&#8221; Oh great. Since she wasn&#8217;t there and all the girls that were were&#8230;hot, then this must be the ugly one. :-) A few weeks pass by and a friend of mine calls me up one night, saying &#8220;Hey, remember that girl that those girls wanted you to meet?&#8221; Me: &#8220;Yeah&#8230;?&#8221; Friend: &#8220;Here she is.&#8221; (click)</p>
<p>One tentative conversation led to a first date. It could have been disastrous since I was late driving out to the boondocks of Long Island after spending the day helping a friend move. She was annoyed and I was tired. However, a good Italian meal and a bad movie made things better. A couple of more dates led to a vacation in Jamaica and the rest, as they say, is history.</p>
<h2>Three</h2>
<p>I used to be very good at math. I was an honors student all through grade school and most of high school. My math skills declined (and my social skills improved) by the time I hit college and took my first calculus course. I suspect the cause of the change may have been either:</p>
<ul>
	<li>My mostly Japanese-speaking professor</li>
	<li>My complete disinterest in anything other than my Computer Science courses</li>
	<li>Girls</li>
</ul>
<p>Now, my math skills seem to be stuck at intermediate algebra.</p>
<h2>Four</h2>
<p>I love comic books and comic book movies. While I no longer collect them, I do have a pretty big collection in my garage. Batman and Iron Man are my all-time favorites. Superman is a punk (he turned down Wonder Woman&#8217;s advances in one issue!! What?!?!) So, when the live action Iron Man movie came out in 2008 as well as Dark Knight, I could have died happy and complete.</p>
<h2>Five</h2>
<p>I am technology agnostic. I&#8217;ve tried lots of different computing platforms. The first computer I ever used was an Apple II and the first one I owned was an Apple IIc. I&#8217;ve had and developed for PCs running <span class="caps">DOS</span>, Windows (3.1 &#8211; XP, including NT and 2000). I have worked on numerous workstations running SunOS, <span class="caps">AIX</span>, HP/UX and Irix. I tried owning a Linux workstation running Red Hat, but it frustrated me no end as a desktop. I might try again soon, as Ubuntu looks promising. Now, I am primarily a Mac user as it hits all the right notes for me.</p>
<p>Note to all Microsoft-bashers: Stop it! It&#8217;s not necessary. And the people that work there are not all bad; in fact, they&#8217;re mostly good people trying to do the right thing in a large corporation. If you don&#8217;t like Microsoft&#8217;s products or behavior, just vote with your dollars! That&#8217;s what really sends the message.</p>
<h2>Six</h2>
<p>My perfect vacation involves a week on an island (generally in the Caribbean) at some sort of all-inclusive resort. My days should consist of deciding whether to swim in the pool or the ocean first, enjoying great meals and getting to catch up on a ton of reading. One day can be allocated to some sort of touristy activity. But, just <span class="caps">ONE</span> day.</p>
<h2>Seven</h2>
<p>It is better to work for me than with me. At least, that&#8217;s what my co-workers say. I fiercely protect my team so that they can focus on doing great things. And, I have trouble managing up but I am trying to get better at that. However, at the end of the day I am an engineer and logic rules my world. My measure of success is building (or helping people build) great products.</p>
<h2>Tag! You&#8217;re it!</h2>
<ul>
	<li><a href="http://www.happymasochist.com/">D. Keith Robinson</a></li>
	<li><a href="http://nickfinck.com/">Nick Finck</a></li>
	<li><a href="http://jeffcroft.com">Jeff Croft</a></li>
	<li><a href="http://navelgaze.org/">Jim Hong</a></li>
	<li><a href="http://www.kevingoldsmith.com/">Kevin Goldsmith</a></li>
	<li><a href="http://seantconrad.com">Sean Conrad</a></li>
	<li><a href="http://garrettmurray.net">Garrett Murray</a></li>
</ul></content>
 </entry>
 
 <entry>
   <title>Is Agile or Lean Enough?</title>
   <link href="http://working-code.com/2009/01/03/is-agile-or-lean-enough.html"/>
   <updated>2009-01-03 00:00:00 -0800</updated>
   <id>http://working-code.com/2009/01/03/is-agile-or-lean-enough</id>
   <content type="html"><p>At the end of the year, I tend to reflect on the progress my team has made and what directions we should take in the new year. Actually, I think about this all the time. However, since the company shuts down I have extra time to be introspective. This year given the snowstorms in Seattle, I&#8217;ve had even more time.</p>
<p>Generally, I have been a proponent of agile techniques. They&#8217;re basically codifications of common sense best practices. For the past few years, I&#8217;ve been particularly attracted to Scrum for managing my development projects. While the basics are pretty easy, Scrum (like most agile methodologies) actually requires a lot of discipline. So, my team and I spent a lot of time increasing our discipline and paying attention to the issues that Scrum surfaced in our development process.</p>
<p>While that approach definitely delivered some benefits, I constantly felt like there were huge gaps in what agile in general and Scrum in particular were bringing to the table. A recent blog post by James Shore, <a href="http://jamesshore.com/Blog/The-Decline-and-Fall-of-Agile.html">The Decline and Fall of Agile</a>, captured some of my concerns:</p>
<blockquote>
<p>It says that the team should be cross-functional and recommends co-locating the team in a shared workspace. It says the team should deliver a valuable, shippable product at the end of every Sprint, and that the team should self-organize, discover impediments, and remove them.<br />
Oh, and it also has a few mechanical things about a monthly Sprint and daily Scrum. Trivial stuff compared to the rest. But guess which part people adopt? That&#8217;s right&#8212;Sprints and Scrums. Rapid cycles, but none of the good stuff that makes rapid cycles sustainable.</p>
</blockquote>
<p>Taking part in many agile discussions at work as well as practicing it on my project, I recognized this as one of the bigger problems. As much as my team and I may want to work in an agile fashion, there were other factors conspiring against us. Co-location was the biggest one and getting a fully cross-functional team in place is not always possible. Shore also states:</p>
<blockquote>
<p>It&#8217;s human nature to only do the stuff that&#8217;s familiar and fun, and that&#8217;s what has happened with Agile. People look at agile methods as a chinese menu of practices, choose the few that look cool, and ditch the rest. Unfortunately, the parts they leave out are the parts that make Agile work. Scrum makes it worse by ignoring important (but hard) agile engineering practices, and the Scrum Alliance makes it worse still with their armies of trainers some good, some not issuing dubious &#8220;ScrumMaster&#8221; certificates to people who demonstrated competence in connecting butt to chair for two days.</p>
</blockquote>
<p>I&#8217;ll be honest, our company offered Scrum training with Ken Schwaber and I took it (Hey, it was <span class="caps">FREE</span>!) And yes, I am now a Certified Scrum Master. And what enlightenment did I receive from this training. Not a whole heckuva lot. In fact, at the conclusion of this training I painfully recalled an enjoyable post from Steve Yegge, <a href="http://steve-yegge.blogspot.com/2006/09/good-agile-bad-agile_27.html">Good Agile, Bad Agile</a>:</p>
<blockquote>
<p>Up until maybe a year ago, I had a pretty one-dimensional view of so-called &#8220;Agile&#8221; programming, namely that it&#8217;s an idiotic fad-diet of a marketing scam making the rounds as yet another technological virus implanting itself in naive programmers who&#8217;ve never read &#8220;No Silver Bullet&#8221;, the kinds of programmers who buy extended warranties and self-help books and believe their bosses genuinely care about them as people, the kinds of programmers who attend conferences to make friends and who don&#8217;t know how to avoid eye contact with leaflet-waving fanatics in airports and who believe writing shit on index cards will suddenly make software development easier.<br />
You know. Chumps. That&#8217;s the word I&#8217;m looking for. My bad-cholesterol view was that Agile Methodologies are for chumps.</p>
</blockquote>
<p>And if you have taken this particular Scrum course and recall the &#8220;secret handshake&#8221; at the end, the <strong>chump</strong> title probably seems like a better name for the certification you received. Sure, there were a few useful bits in terms of clarifying a few ambiguous parts of the standard Scrum literature. However, the course offered no practical help with day-to-day development issues. Specifically, the disconnect from one or more development practices that pair up well with Scrum as Shore notes.</p>
<p>So, reflecting on the past year I see two fundamental issues with our adoption of agile practices. The first is the lack of top-down adoption of agile in our company. While there are many teams adopting agile (specifically Scrum), there is still the cross-functional gap. That leads to a lot of wasted time spent context switching between Scrum and the &#8220;traditional&#8221; development process. I&#8217;ve witnessed a lot of teams say that they&#8217;re <em>doing Scrum</em> but they&#8217;re just re-labeling portions of the legacy process with terms they learned from Scrum. More <strong>fragile</strong> than agile. It seems as if there is not an organizational drive towards continuous improvement that is driven from the top, then it is easy to regress to past behavioral patterns. In <a href="http://www.amazon.com/Scaling-Lean-Agile-Development-Organizational/dp/0321480961/ref=wl_it_dp?ie=UTF8&amp;coliid=I2EDC0NTF1H01X&amp;colid=1HKQWRT70OE52">Scaling Lean and Agile Development</a>, Craig Larman summarizes this nicely:</p>
<blockquote>
<p>There are better ways to build large systems than with many developers in many places. Rather, build a small group of great developers and other talents that can work together in teams, pay them well, and keep them together in one place with product management or whoever acts as the voice of the customer.<br />
But of course you are <em>still</em> going to do large, multisite, or offshore development. This is because your existing system is already structured that way, or because in the case of large groups there is the mindset that &#8220;big systems need lots of people.&#8221;</p>
</blockquote>
<p>THAT&#8217;S what our current situation feels like. And that&#8217;s not something that can be addressed from the bottom up alone.</p>
<p>And my second issue? Exactly what Shore mentioned:</p>
<blockquote>
<p>Scrum makes it worse by ignoring important (but hard) agile engineering practices</p>
</blockquote>
<p>Scrum does not prescribe any development practice to use alongside it. That&#8217;s OK, but one would think that by now the Scrum practitioners would have strong recommendations based on real-world experience. The common wisdom is Extreme Programming (XP), but I have several issues with XP. It seems to be even more of a take-it-all-or-leave-it-all religion than Scrum is. And XP doesn&#8217;t work for all teams. And most agile processes over-focus on the development team, but gloss over the other cross-functional team members.</p>
<p>Now that the Scrum backlash is in full swing, people are starting to embrace Lean. What they fail to realize is that Scrum is just the gateway drug to Lean. Scrum is not a pure pull system, which is what you would have once you Got Lean. After reading Corey Ladas&#8217; <a href="http://leansoftwareengineering.com/ksse/scrum-ban/">blog post</a> and <a href="http://www.lulu.com/content/3864767">book</a> some of the ideas resonated with me. But, this was only because I had years before been a fan of the Theory of Constraints and Eliyahu Goldratt&#8217;s books (sidebar: his books are great due to his ability to communicate dry, academic topics via engaging novels). And again, the pragmatic issues around cross-functional product development processes are still largely ignored.</p>
<p>So, in 2009, how will I evolve my team&#8217;s processes? We&#8217;ll probably continue with Scrum or even &#8220;evolve&#8221; towards Lean. But our focus will be on sharpening our engineering practices. We&#8217;ve been pretty good about constant communication and unit testing, but we can probably tighten up our feature designs and code reviews. It&#8217;s all about balance.</p></content>
 </entry>
 
 <entry>
   <title>Welcome!</title>
   <link href="http://working-code.com/2008/12/29/first.html"/>
   <updated>2008-12-29 00:00:00 -0800</updated>
   <id>http://working-code.com/2008/12/29/first</id>
   <content type="html"><p>Welcome to [working code]</p></content>
 </entry>
 
 
</feed>